package httpgw

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"fmt"
	"log/slog"
	"math/big"
	"net"
	"os"
	"path/filepath"
	"time"
)

// CAConfig holds the configuration for the CA manager.
type CAConfig struct {
	// CertFile is the path to the CA certificate PEM file.
	// Default: "~/.sentinelgate/ca-cert.pem".
	CertFile string

	// KeyFile is the path to the CA private key PEM file.
	// Default: "~/.sentinelgate/ca-key.pem".
	KeyFile string

	// Organization is the subject organization for the CA certificate.
	// Default: "SentinelGate TLS Inspection".
	Organization string

	// ValidityYears is how many years the CA certificate is valid.
	// Default: 10.
	ValidityYears int
}

// caConfigDefaults applies sensible defaults to a CAConfig.
func caConfigDefaults(cfg CAConfig) CAConfig {
	if cfg.CertFile == "" {
		home, _ := os.UserHomeDir()
		cfg.CertFile = filepath.Join(home, ".sentinelgate", "ca-cert.pem")
	}
	if cfg.KeyFile == "" {
		home, _ := os.UserHomeDir()
		cfg.KeyFile = filepath.Join(home, ".sentinelgate", "ca-key.pem")
	}
	if cfg.Organization == "" {
		cfg.Organization = "SentinelGate TLS Inspection"
	}
	if cfg.ValidityYears == 0 {
		cfg.ValidityYears = 10
	}
	return cfg
}

// CAManager manages a CA keypair for TLS inspection.
// It auto-generates an ECDSA P-256 CA on first use, persists it to disk,
// and loads it from disk on subsequent starts. It can generate per-domain
// leaf certificates signed by the CA for MITM decryption.
type CAManager struct {
	caCert *x509.Certificate
	caKey  crypto.PrivateKey
	config CAConfig
	logger *slog.Logger

	// caCertPEM is the PEM-encoded CA certificate, cached for CACertPEM().
	caCertPEM []byte
}

// NewCAManager creates a new CAManager. If both CertFile and KeyFile exist
// on disk, they are loaded. If neither exists, a new CA keypair is generated
// and persisted. If only one file exists, an error is returned (inconsistent state).
func NewCAManager(config CAConfig, logger *slog.Logger) (*CAManager, error) {
	config = caConfigDefaults(config)

	certExists := fileExists(config.CertFile)
	keyExists := fileExists(config.KeyFile)

	switch {
	case certExists && keyExists:
		return loadCAFromDisk(config, logger)
	case !certExists && !keyExists:
		return generateNewCA(config, logger)
	default:
		return nil, fmt.Errorf("inconsistent CA state: cert=%s (exists=%t), key=%s (exists=%t)",
			config.CertFile, certExists, config.KeyFile, keyExists)
	}
}

// GenerateCert creates a new TLS leaf certificate for the given domain,
// signed by the CA. The returned tls.Certificate contains the leaf cert,
// its private key, and the CA cert in the chain.
func (cm *CAManager) GenerateCert(domain string) (*tls.Certificate, error) {
	// Generate a new ECDSA P-256 key for the leaf
	leafKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("generate leaf key: %w", err)
	}

	serialNumber, err := randomSerial()
	if err != nil {
		return nil, fmt.Errorf("generate serial: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName: domain,
		},
		NotBefore:   now,
		NotAfter:    now.Add(24 * time.Hour),
		KeyUsage:    x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	// If domain is an IP address, add it as an IP SAN; otherwise as a DNS SAN.
	// x509 requires IP SANs for IP address validation (DNS SANs are ignored for IPs).
	if ip := net.ParseIP(domain); ip != nil {
		template.IPAddresses = []net.IP{ip}
	} else {
		template.DNSNames = []string{domain}
	}

	// Sign with CA cert/key
	leafDER, err := x509.CreateCertificate(rand.Reader, template, cm.caCert, &leafKey.PublicKey, cm.caKey)
	if err != nil {
		return nil, fmt.Errorf("sign leaf cert: %w", err)
	}

	// Build the tls.Certificate with leaf cert + CA cert in chain
	leafCert, err := x509.ParseCertificate(leafDER)
	if err != nil {
		return nil, fmt.Errorf("parse leaf cert: %w", err)
	}

	tlsCert := &tls.Certificate{
		Certificate: [][]byte{leafDER, cm.caCert.Raw},
		PrivateKey:  leafKey,
		Leaf:        leafCert,
	}

	return tlsCert, nil
}

// CACertPEM returns the PEM-encoded CA certificate.
// Clients should add this to their trust pool to accept leaf certs
// generated by this CA.
func (cm *CAManager) CACertPEM() []byte {
	return cm.caCertPEM
}

// CACertPath returns the file path to the CA certificate.
func (cm *CAManager) CACertPath() string {
	return cm.config.CertFile
}

// loadCAFromDisk loads an existing CA keypair from disk.
func loadCAFromDisk(config CAConfig, logger *slog.Logger) (*CAManager, error) {
	tlsCert, err := tls.LoadX509KeyPair(config.CertFile, config.KeyFile)
	if err != nil {
		return nil, fmt.Errorf("load CA keypair: %w", err)
	}

	caCert, err := x509.ParseCertificate(tlsCert.Certificate[0])
	if err != nil {
		return nil, fmt.Errorf("parse CA cert: %w", err)
	}

	certPEM, err := os.ReadFile(config.CertFile)
	if err != nil {
		return nil, fmt.Errorf("read CA cert PEM: %w", err)
	}

	logger.Info("loaded existing CA keypair",
		"cert", config.CertFile,
		"serial", caCert.SerialNumber.String(),
	)

	return &CAManager{
		caCert:    caCert,
		caKey:     tlsCert.PrivateKey,
		config:    config,
		logger:    logger,
		caCertPEM: certPEM,
	}, nil
}

// generateNewCA creates a brand new ECDSA P-256 CA keypair, persists it to disk,
// and returns a CAManager.
func generateNewCA(config CAConfig, logger *slog.Logger) (*CAManager, error) {
	// Generate ECDSA P-256 key
	caKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("generate CA key: %w", err)
	}

	serialNumber, err := randomSerial()
	if err != nil {
		return nil, fmt.Errorf("generate serial: %w", err)
	}

	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{config.Organization},
		},
		NotBefore:             now,
		NotAfter:              now.AddDate(config.ValidityYears, 0, 0),
		IsCA:                  true,
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
		BasicConstraintsValid: true,
	}

	// Self-sign
	certDER, err := x509.CreateCertificate(rand.Reader, template, template, &caKey.PublicKey, caKey)
	if err != nil {
		return nil, fmt.Errorf("create CA cert: %w", err)
	}

	caCert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, fmt.Errorf("parse CA cert: %w", err)
	}

	// PEM-encode cert
	certPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certDER,
	})

	// PEM-encode key
	keyDER, err := x509.MarshalECPrivateKey(caKey)
	if err != nil {
		return nil, fmt.Errorf("marshal CA key: %w", err)
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "EC PRIVATE KEY",
		Bytes: keyDER,
	})

	// Write to disk with correct permissions
	if err := writePEMFile(config.CertFile, certPEM, 0644); err != nil {
		return nil, fmt.Errorf("write CA cert: %w", err)
	}
	if err := writePEMFile(config.KeyFile, keyPEM, 0600); err != nil {
		return nil, fmt.Errorf("write CA key: %w", err)
	}

	logger.Info("generated new CA keypair",
		"cert", config.CertFile,
		"key", config.KeyFile,
		"serial", caCert.SerialNumber.String(),
		"valid_until", caCert.NotAfter.Format(time.RFC3339),
	)

	return &CAManager{
		caCert:    caCert,
		caKey:     caKey,
		config:    config,
		logger:    logger,
		caCertPEM: certPEM,
	}, nil
}

// writePEMFile writes data to a file, creating parent directories with 0700.
func writePEMFile(path string, data []byte, perm os.FileMode) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("create directory %s: %w", dir, err)
	}
	return os.WriteFile(path, data, perm)
}

// fileExists returns true if the file at path exists and is not a directory.
func fileExists(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return !info.IsDir()
}

// randomSerial generates a random 128-bit serial number for X.509 certificates.
func randomSerial() (*big.Int, error) {
	serialLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serial, err := rand.Int(rand.Reader, serialLimit)
	if err != nil {
		return nil, errors.New("failed to generate random serial number")
	}
	return serial, nil
}
